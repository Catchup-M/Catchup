<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PUBG Style Mobile Joystick</title>
  <style>
    html,body{
      background:#ffffff;
      margin:0;
      height:100%;
      overflow:hidden;
    }

    /* ðŸ”¥ Position joystick bottom-left like PUBG */
    #c {
      position:fixed;
      bottom:40px;   /* distance from bottom */
      left:40px;     /* distance from left */
      touch-action:none; /* prevents scrolling while controlling */
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// Small mobile scale
const OUTER_RADIUS = 70;
const RING_THICKNESS = 10;
const KNOB_RADIUS = 20;
const KNOB_STROKE = 5;

function resize() {
  const size = (OUTER_RADIUS + RING_THICKNESS + 10) * 2;
  canvas.width = size;
  canvas.height = size;
  draw();
}

function drawBackground() {
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

const center = {x:0,y:0};

const state = {
  knobPos: {x:0,y:0},
  dragging:false
};

function drawRing() {
  const cx = center.x, cy = center.y;

  // Outer ring
  ctx.beginPath();
  ctx.lineWidth = RING_THICKNESS;
  ctx.strokeStyle = "#000";
  ctx.arc(cx, cy, OUTER_RADIUS, 0, Math.PI*2);
  ctx.stroke();

  // Knob
  const knobX = cx + state.knobPos.x;
  const knobY = cy + state.knobPos.y;

  ctx.beginPath();
  ctx.lineWidth = KNOB_STROKE;
  ctx.strokeStyle = "#000";
  ctx.arc(knobX, knobY, KNOB_RADIUS, 0, Math.PI*2);
  ctx.stroke();

  ctx.beginPath();
  ctx.fillStyle = "#ffffff";
  ctx.arc(knobX, knobY, KNOB_RADIUS - KNOB_STROKE/2, 0, Math.PI*2);
  ctx.fill();
}

function draw() {
  drawBackground();
  center.x = canvas.width/2;
  center.y = canvas.height/2;
  drawRing();
}

// Convert pointer to local coords
function clientToCanvas(ev){
  const rect = canvas.getBoundingClientRect();
  let x,y;
  if (ev.touches){
    x = ev.touches[0].clientX;
    y = ev.touches[0].clientY;
  } else {
    x = ev.clientX;
    y = ev.clientY;
  }
  return {
    x: (x - rect.left) * (canvas.width / rect.width),
    y: (y - rect.top) * (canvas.height / rect.height)
  };
}

function pointerDown(ev){
  ev.preventDefault();
  const pos = clientToCanvas(ev);
  const dx = pos.x - center.x - state.knobPos.x;
  const dy = pos.y - center.y - state.knobPos.y;
  if (Math.hypot(dx,dy) <= KNOB_RADIUS + 5) {
    state.dragging = true;
  }
}

function pointerMove(ev){
  if (!state.dragging) return;
  ev.preventDefault();
  const pos = clientToCanvas(ev);

  let nx = pos.x - center.x;
  let ny = pos.y - center.y;

  const mag = Math.hypot(nx,ny);
  const max = OUTER_RADIUS - KNOB_RADIUS - (RING_THICKNESS/2);

  if (mag > max){
    nx = nx/mag * max;
    ny = ny/mag * max;
  }

  state.knobPos.x = nx;
  state.knobPos.y = ny;
  draw();
}

function pointerUp(){
  state.dragging = false;
  state.knobPos.x = 0;
  state.knobPos.y = 0;
  draw();
}

// Listeners
canvas.addEventListener("mousedown", pointerDown);
window.addEventListener("mousemove", pointerMove);
window.addEventListener("mouseup", pointerUp);

canvas.addEventListener("touchstart", pointerDown, {passive:false});
window.addEventListener("touchmove", pointerMove, {passive:false});
window.addEventListener("touchend", pointerUp);

// Initialize
resize();
</script>

</body>
</html>
